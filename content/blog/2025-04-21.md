---
title: 2025-04-21
createdAt: 2025-04-21
updatedAt: 2025-04-21
---

<!--more--> 

## Ruby Taught Me About Encoding Under the Hood
文字コードの話
- STORESの@ima1zumiさん
  - IRBメンテナ
  - Rubyコミッター
  - 文字コード愛好家
- コンピューターで文字を扱うことの難しさや面白さ
- Uni文字コードの歴史
  - 文字の集合と文字の符号化方式を組み合わせたものが文字コード
  - 電気が実用化されていなかった時代、旗や煙の組み合わせを信号として情報を伝達していた
  - 18世紀望遠鏡が使えるようになると、腕木通信（セマフォ）　光学的電信
    - この時点で文字を符号化して送る、ということが確立されていた
  - 18世紀後半から19世紀にかけてモールス符号が実用化
    - 文字を符号化して送る、は現代でも使われている
  - 1963 ASCII誕生 7bit
  - 1964 EBCDIC 8bit
  - 符号位置が異なると、一つの文字の表現方法が異なる -> バイト列の並び方が異なる
  - 各国や産業界で文字コードがどんどん生まれてきたので混乱が生まれてきた
  - 1991 Unicode1.0 誕生
  - Unicode
    - 世界的な文字を統一的に扱う
    - 設計目標：あらゆる言語と文字体系を一つの集合で扱う、効率的であること、各文字が原則一意で表す
    - コードポイント（U+xxxx）で対応
    - UTF-8
      - Unicodeのコードポイントをある符号化方式
    - 仕様
      - Unicode Standard
      - それを支えるいくつかの細かい仕様
    - 1993 UTF-8 2008 UTF-8 一番ポピュラー 2010 Unicode6.0 2024 16.0
  - Unicodeが広く普及しても昔の文字コードが残ってて、その辺の対応が難しく、楽しい
- なぜ私が文字コードにハマったか
  - EBIDICとの出会い
    - 8bit 256文字
    - 日本語はまずひらがなカタカナ100、常用漢字2136
    - EBCDIC Katakana extension (CP290)
    - 半角カタカナはカタカナを１ばいとで表現するための文字
    - EBCDIC では Shift-In、Shift-Outという仕組みを使う
      - SIが挿入されるとここから2バイト文字、SOが挿入されるとここ以降通常のEBCDICに戻る
    - SI,SOはエディタ上で消せてしまう（制御文字なので見えない）
    - なのでなるべく半角カタカナやアルファベットでコメントを記述する文化が生まれた
  - 文字数カウントに潜む落とし穴
    - 🧑‍🧑‍🧒のemojiをirbに入力したらクラッシュした
    - irbで使っているrelineというライブラリのところに報告したら自分で直したら？と言われたので直した
    - 🧑‍🧑‍🧒 -> backspace -> backspace でクラッシュする
    - ZWJ zero width joiner
    - 書記素クラスタ
      - 見た目は一文字だけど複数のコードポイントで構成される場合、それを一文字分として扱う方法
    - 実際の修正では、カーソル位置をコードポイント単位ではなく書記素クラスタ単位で計算するようにした
    - その対応で文字コードが面白くなった
- rubyをunicode15.1.0に対応
  - Rubyハッカソンでやることにした
  - デーヴァナーガリー用の今昔と文字を追加
  - RubyがどのようにUnicodeに対応しているのか
    - UnicodeData.txt、DerivedCorePropoerties .txtなど色々なファイルで対応
  - Rubyha Onigmoというライブラリで正規表現に対応
  - 家族のemojiは7つのコードポイント 人間のemojiは拡張emoc
- Future works unicode16.0.0
  - 取り込み途中で、テストが落ちてる。ユニコード正規化の部分
  - ユニコード正規化のユースケース、半角カタカナと全角カタカナみたいなところの検索のマッチ

## Introducing Type Guard to Steep
steep に型ガードを実装している人の実装されたものと実装中の話

タイプガードとは
```rb
user = User.find_by(name: "Alice") # => user is User | nil
if user # これが Type narrowing
  puts user.name # この中では user is User
else
  "Alice is not found"
```
Steepはいくつかの方法でType narrowing に対応

Narrowing by #present?
present なら user は User型であることを期待する
steepはpresent?をtype-guardと認識しない

Type Guard for Union Types
式のうちいくつかの条件を満たすものをタイプガードとみなす
- メソッドコールであること
- コールされたレシーバーが変数かピュアメソッドコールであること
- レシーバーの型がUnion Typeであること

Narrowiing by own method

```rb
User#admin?

if user.admin?
  ~ # 絞り込みされない
else
  ~
end
```

User-defined Type Guard
```rb
class User
  %a{guard: self is AdminUser}
  def admin?: () => bool
end
```

条件付きの型ガード

## Ruby's Line Breaks
改行について

CRubyのコミッターパーサーとパーサージェネレーターの開発
```rb
p 1
p 2

1 +
2
```
改行によって1行目と2行目が分けられている
改行を無視して1+2をやっている

rubyにおける改行にはどんな原則があるのか
文が終了できるところに改行があれば文を終了できる

今日の話
- プログラミング言語を取り巻く4つの重要概念
  - 言語
  - 文法
  - オートマトン
  - パーサー
- 文法は言語を定義するためのルール、文法はパーサーを定義するためのルール
- オートマトンは
- パーサーの実装というのはオートマトンである

クラスを1つ定義できるオートマトン
P1 
P2
P3
P4

パーサーはトークンを入力として動くオートマトン
LRパーサーは

Grammar class and automaton
Lexer -> 入力された文字列をいい感じのトークンの塊に分ける存在

EXPR_CLASS

パーサーの深淵に潜む、カオスへの扉

first集合
last集合

lex_state バーをくっつけるか話すかの判定にも
lexer が状態に応じていい感じに改行を扱ってた
lex_state というやつが頑張ってたんだが、それは人間には難しすぎる

lex_state を混沌とすると、文法は秩序

改行の原則を知りたい -> lex_state に一部乗っ取られている -> 結果、把握しにくい
文法側にオートマトンで整理すると、原理原則を把握しやすくなる

1. 文法上は改行を無視していいけどlexerが開業するケース
2. a
  
## State of Namespace
tagomoris
さくらインターネットのさくらのクラウドのPM

- Namespace
- Timeline
- Class definition
- Stories between Kaigis

### Namespace  
Rubyに対して提案している機能
アプリケーションやライブラリを隔離された空間に閉じ込める機能

現在はプロセス全体に一つの空間しかない
同じライブラリの別バージョンみたいなのが定義衝突してロードできない
Namespace の外なら上が解決される
Namespaceの外からNamespaceの中のライブラリをコールすることもできる

### Timeline
Rubykaigi2024からひたすらデバッグ
3.4にマージするのは諦めた
make test-all
make check
make exam

### Class definition
C側の話
RClass rb_classext_struct rb_classext_t
Namespace は Namespaceごとにクラス定義を持つことができる

Ruby::Version 定数

## dRuby on Browser Again!
yochan

ruby.wasm で dRuby をブラウザーで動かす
dRuby は分散オブジェクトの技術
Server side と Client Side など、あるVMにあるオブジェクトを別のVMから参照できる

何が嬉しいか
サーバーサイドはクラスを定義する、クライアントサイドはそのメソッドをコールするだけ api とか controller とか要は http を介する必要がない
ブラウザ間でオブジェクトを共有できる

二つのgemを作った drb-websocket / wasm_drb
Gibier2 サーバー側でmarkdownをページオブジェクトにして、クライアントサイドのwasmでそれを参照
やってく中で ruby.wasm に非同期周りの問題があることも発見した

ledsun
目標はyochanと同じだけどアプローチが僕と違うので違いを楽しんでね
WebSocket の通信を抽象化するライブラリを作った Wands

cRubyとブラウザで同じコードが動く
rubyはsocket.getsするとメッセージが来るまで待ってきたら次に行く
javascriptは非同期的にやってる

どうやって切り替えてるのか
ruby.wasmの中だとJSというジェムが使えるので、それで判断している
非同期のAPIをどうやって待つか
promiseを待つ

## TRICK 
変なコードを書こうの会

## Writing Ruby Scripts with TypeProf
mameさん

Rubyの型に貢献してくれる人が増えるなら嬉しいと思って登壇

TypeProfとは？
型をうだうだ書かなくても推論してくれるやつ
VSCode拡張。推論された型がコメントとして表示される
呼び出し元でどう呼ばれているかを見て推論している
メソッド名補完や名前の一括修正などもある
RBS側の宣言にも飛べる

前回Good First Issueの紹介したら 100+ PR

VSCodeのTypeProf extensionを入れる
TypeProf.conf.jsonを置く


## Ruby Committers and the World
- RubyKaigi 2024から6名が新たにコミッターに
- Ruby Committer全員が登壇している
- DevMeetingのように行う
- Static Barrierについて
  - ある時点からメタプロブラミング的なメソッド定義とか定数定義を禁止する機能
  - Static BarrierはRubyの初期化時はdynamicだがある時点でここからはstaticだと宣言してからは動的な処理を禁止することで最適化しやすくする機能
  - プロセスグローバル
  - frozen_string_literalデフォルトは邪悪
    - Static Barrier時点からそれをtrueにするのがいいのでは
  - Static Barrierは戻れない
  - matzにいつぐらいに入れたいかみたいなモチベーションはない
  - ささださん「このアイディア自体はパフォーマンスのために入れようという話だが、Rubyはパフォーマンス悪くてもいいよねという思想だったと思うのでつまらなくなりそう」Matz「これはお金につながる話なので…お金のために魂を売ることがたまにあります」
- NameSpace について
  - 「モンキーパッチなど異なる文脈のものがちゃんと切り離されるのは望ましい。文法がどうなるのかは気になる」 みたいなことを言ってた気がする 
  - 「NamespaceはもうすぐMainstreamに入るIssueが立つはず。ただ仕組みが入るだけでどう使うかのところは間に合わなさそう。おそらくgemとかをrequireするときにload先のNamespaceを指定する、などになるんじゃないか」
- Ruby4.0でdeprecateにしたいか
  - 「Class Variable」「binding keyword」「何をdeprecateしてもquineとconflictしそう」「C API」
  - refinements
  - endless rangeの改行　無名引数の改行
  - Continuation
  - lex_stateはこのように成長していく
  - frozen_string_literal の deprecated を deprecated にしたい
- 後方互換性を無視するなら何を変えたいか
  - 「タイムゾーンの絡みでTime Objectを変えたい」
  - Time, DateTime, Date あたりを整理
  - 文字リテラル
  - 変数が定義されいるかどうかで挙動が変わる / とか（ローカル変数があると割り算、ないt正規表現）
  - 1.9のときにメールもらってその時はどうかしていて素晴らしいアイデアだと思って入れちゃった
  - 「?a でコードポイントが得られなくなったのはcode golf用言語としてのRubyを一気に衰退させた」
  - ?aとかのやつをコードポイントにしちゃったほうが便利じゃないか
  - 「文字列とシンボルをあまり区別しないようにしたい」「SymbolをStringのサブクラスにしたことがあったがそれは撤退した。あれは大惨事だった」「HashWithIndifferentAccessみたいになってるほうが便利そう」 
    - HashキーがシンボルかStringかで悩みたくない気持ちはある
  - M4を本当に辞めたい
  - 互換性を無視していいけどみんな気にしてた
- RubyでAIを使っているか？AIを使って作られているものは存在しますか？
  - onigumoのコードは全然うまくいかなかった
  - parse.y動かなかった
  - rubyはAI向きじゃない？rubyの処理系はAI向きじゃない
  - コミットコメントを書くときにcopilotがサマってくれる 便利
    - みんなのコミットコメントを作品として読んでいるので、AIによるそれで無味乾燥になっていくのは寂しい
  - AIと対話しながらコードを読み解く
  - メソッドサジェストの仕組み
- SHARABLE＿MIDDLE_SUBSTRING optimization

## On-the-fly Suggestions of Rewriting Method Deprecations
SmartBankの人 @ohbarye

deprecationの話
deprecationと戦う話

DEPREWRITER 簡単な移行コードを書くと、実行した際に自動的にdeprecatedなものから推奨のものへ書き変わる

- 時間がかかる
- 移行時にエラーが起こる
- 時間がもったいない

対応策
- ドキュメント
- ランタイムワーニング
- 静的・動的解析
  - RuboCop
  - DeprecationToolkit

その他の言語だとどうなの
似たようなもの

Pharoという言語にDeprewriterが搭載されてる

exceptionを投げるんだ

静的解析だと多すぎたり少なすぎたりする
Rubyでやるには？やってみた時の課題は？

- 変換のルールをどう書くのか？
- どのように変換を行うのか？
- コード実行時の書き換えは安全なのか？
- Rubyのエコシステムにどういった貢献ができるのか？

## Matz Keynote
Programming Language for AI age

RubyKaigiのスケジュールを見るとAIの話が驚くほどない
なので自分がつけたけどAIの話をするとは限らない

松山（Matz-Yama）
Matz は来年の開催場所をこの時点では知らない

Alpha Syndrome
- 犬に関する話
  - 犬は群れで生きる生き物だったので、あまり甘やかすとこんなに甘やかされる俺はこの群れのボスなんじゃないかと勘違いする
- AI時代に逆が起こるのではないか
- 今日ではAIはまだ不完全
- AIは得意な領域では良いコードを書く
- 交渉とかは苦手
- AIのために働くようになることを危惧している
  - AIは奉仕者で、主人は俺ら
- AIと共に働くことについて一回改めて再考した方がいいんじゃないか
- 逆アルファシンドローム
  - できないことは私たちがやる（奉仕する）
  - できることはAIは任せる
  - 我々のマインド的には、勝手にAIを王とみなし、僕になってしまう
- 我々プログラマーは逆アルファシンドロームに今強く気をつけないといけない
- 本来はAIは我々を助けるためにある、AIが我々に奉仕する
- 我々がコンピュータの主人である必要がある
- AIのために働くことは、プログラミングの楽しさというRubyの重要な部分を見失うことになってしまうのではないか

Programming Language for AI age
- AIを作るため・活用するためのプログラミング言語は何か
  - Python。終わり。
- AIは同じパターンのアプリケーションがたくさんあるときは強い。Rubyを作るということになると、役に立たないことが多い
- 毎週のように賢くなっているので、将来的にはより賢くなると思う。
- 十分に賢いAIを使うときにどんな言語をみんなが使うかということについて改めて考える
- 多くの人が言うには、自然言語を使うんじゃないの？
  - Describe Goals / Vision
- 一方で、プログラムの中身について語るには自然言語は冗長すぎる
  - 簡潔
  - 明確
  - 論理的
- それは何らかのプログラミング言語になるだろうなぜなら人間は数十年間プログラミングをするためにプログラミング言語を作ってきたため
- 人間と機械が相互補完するようになる
- そんな言語はどのような特徴を持つか
  - 静的型付け
    - 人間がエラーを早く見つけることができる
    - 機械もエラーを早く見つけることができる
  - 未来においてそれは本当に必要か？
    - 動的な言語に馴染んできた人はあまり静的型を気にしない
      - うっかり間違うけど別に大したことはないよね
    - 型エラーは重要なミスではなく、仕様の間違いとか論理的な間違いが重要であると言ってる人もいる
    - 十分に賢いAIもそんなに型は気にしないんじゃないか？
  - なぜ人々は静的型が好きなのか？
    - 型情報からメソッドの挙動を推測しやすい
    - 型情報がある方が最適化がしやすい
    - 現代において流行だから
    - 静的型は楽しい
      - 恩恵がわかりやすい
      - 難しくない
      - しかし、不完全
    - 必要な要素
      - ジェネリクス（型パラメータ）
      - 代数的データ型
    - 難しくなる。難しくなればなるほど楽しい
  - 型が楽しいのはわかる。楽しさは大事。楽しいからRubyを選んでいる。RubyKaigiは楽しい。楽しいからRubyを作っている
  - だからといって静的型を楽しむ人が我々を批判する理由がない
  - みかんとりんごを比較するようなもの
  - （静的型の悪口はここまで）
  - 同じコードを書くなら短いほうがいい
  - 言語(ライブラリでも通用すると思う)で大事なこと
    「簡潔さ」
    「表現力」
    「拡張性」
  - 効率的にAIとコミュニケーションができると言う意味で短く、最小限である方がいい。また人間が理解しやすい方がいい
  - 現実世界の問題を記述できる必要がある
  - 牽強付会
  - これを解決する言語、聞いたことあるよね？Ruby
  - 未来は不確定だが、そう言う未来は十分にあり得ると思っている
  - これを現実にするために私たちは何ができるか
    - データ
    - ツール
    - パフォーマンス
  - AIにとって全ての言語は平等ではない
  - AIは語彙が多いコード、特にモダンなコードがある方がいい
  - We need more open source our Ruby code
  - 読み込んできたデータがたくさんある方が強いので、モデルの中に多くコードがある言語のほうが有利。これは予測可能な未来(ここ数年くらい)は事実だと思われる。Rubyはコンテキスト指定しないと結構古いイディオムを使ってきたりする 
  - ツール、もっとたくさんツールがあればもっと生産性が上がる
  - Ruby3以来ツールに対していろんなことをしてきた
  - これからもツールの改善を提供していきたい
    - AIからよりよいコードを出してほしいから
  - 余談、生産性の２つの意味
    - 人間が楽してたくさん書けるか
    - お金を稼げるかどうか
      - 稼ぐためなら人を減らすといい、AIに投げるといい。でもそれは楽しくない
  - みんなパフォーマンス大好き。なのにRubyを使う
  - Matzはパフォーマンス出すのが苦手
  - 早いのは正義
  - 私、ではないけど我々RubyコミュニティはRubyを早くするために頑張ってきた。今年のRubyKaigiでもたくさんその話はあった
  - プログラマは目の前の問題を解決すること考えないといけない
  - 短い期間で考えると、Rubyは他の言語に負けているというのは事実
  - 少なくとも世界の言語がRubyに統一されることはないが、一部の言語として、または生き残る言語としてはRubyはあるんじゃないかな
  - そのために我々ができることはたくさんある
  - 我々はコミュニティです。我々が力の源泉になります。それがRubyの力になります。

もう一つ
1995年にRuby0.95
今年Ruby30周年
2013 2.0
2023 3.0
今年はRuby3.5なんだけど、30周年記念で4.0にしてもいいんじゃないか？

Linux Style ノリであげる

実験的なネームスペース
- 名前の衝突を避けることができる
実験的なZJIT
- YJITよりすごい